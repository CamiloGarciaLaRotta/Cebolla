\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsfonts, mathtools}
\usepackage{enumitem}                   
\usepackage{listings}                   % insert code
\usepackage{graphicx}                   % Insert images
%\graphicspath{ {images/} }
\usepackage[letterpaper, margin=1.5cm]{geometry}
\usepackage[singlespacing]{setspace}

\begin{document}
\noindent
\large \textbf{ECSE 414 Intro. to Telecom. Networks} \hfill \textbf{Camilo Garcia La Rotta} \textbf{\#260657037} \\
\large \textbf{Deliverable \#1 - Description} \hfill \textbf{Jastaj Virdee} \textbf{\#260689027} \\
\text{} \hfill \textbf{Edward Zhao} \textbf{\#260690376}\\
\text{} \hfill \textbf{Harley Wiltzer} \textbf{\#260690006}\\
\text{} \hfill \textbf{Spiros-Daniel Mavroidakos} \textbf{\#260689391}\\
\text{} \hfill \textbf{Stuart Mashaal} \textbf{\#?????????}\\

\section*{Methodology}
%The implementation of the Onion Routing protocol will involve having several
%computers running servers that will handle the processing and transmission of packets along a path.\\
%The following will outline the tactics that will be used in order to ensure
%that data may be sent anonymously across several intermediary nodes in such a
%way that each node only knows the source of the data and the destination of the
%next node. The protocol will ensure that only the sender knows which
%intermediary nodes are accessed, and thus no intermediary nodes know the full
%path of nodes in the transmission.\\
%The following will outline the tactics that will be used to ensure that a sender
%$\mathcal{S}$ can transmit a message to a destination, $\mathcal{D}$, with the security
%guarantees outlined above.\\\\
The Onion Routing protocol will be implemented with several independent routers
that will be referred to as nodes that communicate via TCP and HTTP packets.
Each node has a key pair that can be used to implement asymmetric cryptography.
Additionally, there will be a special server called the Directory Node. This
Directory Node contains a set of all $n$ node address and public key pairs: $\{(a_i,
p_i) | 0 \leq i < n\}$, where $a_i, p_i$ are the address and  public key
corresponding to node $i$, respectively.\\\\
Say a sender $\mathcal{S}$ wishes to send a request (and receive a response)
from some destination $\mathcal{D}$.
Firstly, $\mathcal{S}$ establishes a TCP connection to the Directory Node,
which generates a random path of nodes through which $\mathcal{S}$ will send
his message. For each node $n_i$ in the list, the Directory Node negotiates
with the corresponding $p_i$, thereby producing symmetric keys $s_i$ for each
intermediate node. The Directory Node then constructs a packet containing
$\{(a_i, s_i), n_i \in \mathbf{path}\}$ and encrypts it with the public key
corresponding to $\mathcal{S}$, and sends the cipher to $\mathcal{S}$.\\\\
Now, $\mathcal{S}$ can decrypt the cipher with his private key. He creates the
request he wishes to send to $\mathcal{D}$, and encrypts with each $s_i$
successively, in reverse order (so the first $s_i$ he encrypts with corresponds
to the last node in the path). Before encrypting with each $s_i$, a header
indicating which node to send to next is prepended so that each node can
determine where to send the packet after decrypting. The sender proceeds to
send this cipher to the first node in the path.\\\\
Each intermediate node behaves according to the exact same protocol. Upon
receiving a packet, an intermediate node $n_i$ can decrypt the packet with its
symmetric key, and can determine the node $n_{i-1}$ immediately before it in
the path. Upon decrypting, the node can read the address of the next node $n_{i+1}$
in the path, and sends the packet to $n_{i+1}$. Then, the node waits for a response packet. Upon receiving the response packet, $n_i$ encrypts the response with $s_i$ and sends the packet to $n_{i-1}$.
When $\mathcal{S}$ receives the response, he may decrypt with each symmetric
key successively, and can then read the response.\\\\
%which responds with  list of node addresses and public keys to $\mathcal{S}$ describing the nodes that
%will construct the path that a message will follow. \\\\
The node servers (and Directory Node server) will be programmed with the Python
programming language, and will use the Flask framework to handle concurrent
requests. The Vagrant tool will be used to automate the creation of virtual
machines which will simulate the nodes. Additionally, to save processing power,
the Directory Node will run locally on the sender's machine for the purposes of
the simulation.\\\\
Furthermore, the NTRU cryptoscheme will be considered and investigated to
provide key exchange for communicating the $s_i$ keys, and can maintain
security against quantum opponents.

\section*{Testing}
The goal of the project is to achieve a minimalist implementation of onion
routing and perform analysis of its performance via simulation. As such,
testing of this project should be divided into two sections:
\begin{enumerate}
	\item \textbf{Verify and validate the onion routing implementation:} We
		will follow a Test Driven Development (TDD) paradigm. Writing test
		cases first, then deriving the unit tests through equivalence
		partitioning and finally writing the necessary code for all the tests
		to pass. Throughout this iterative process we will rely on Continuous
		Integration (CI) to efficiently manage all the source code generated by
		each sub-team. The concept of pair programming will be leveraged in
		order to equally subdivide the tasks among the group and to ensure
		regular code reviews are performed on the code base. With respect to
		the application testing, we shall focus on three main aspects of onion
		routing: \underline{bidirectional communication}, \underline{encryption
		of data through nodes} and \underline{randomized path selection}. Each
		of these characteristics will be unit tested with virtual machines and
		after satisfying our requirements they will be undergo integration
		testing. In order to efficiently replicate the development and testing
		environment across the machines of each team member, Vagrant will be
		used to build and maintain the portable virtual development
		environments.
	\item \textbf{Analyze the performance of the application through
		simulation:} There will be two tools that will be used, one is Nmap
		which provides a broader overview of the network and Wireshark to
		examine the packets transferred between nodes. We will be using Nmap
		for testing enumeration of network components and available application
		layer protocols at end hosts. It will also be used to identify any
		vulnerabilities in the network and to ensure the ports are connected to
		the correct hosts. Wireshark is used to test encryption requirements,
		provide an analysis of the chosen network and ensure contiguous nodes
		know the adjacent source destination and not the global ones. For
		further testing, we may use the mentioned tools such as Brite or Orbis
		to generate network topology to simulate characteristics in the
		internet.
    
% As for the second section of testinng (performance) we gotta find some tools for network testing (i.e. nmap, wireshark) and talk about 
% how we will benchmark those tests ina very high level manner

\end{enumerate}


\section*{BlaBlaBla}


\end{document}
